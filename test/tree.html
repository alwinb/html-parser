<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Tree Builder Test Page</title>
  <link rel="stylesheet" href="style/base.css">
  <link rel="stylesheet" href="style/tree.css">
  <script src="./scripts/console.js"></script>
</head>
<body>

<script>
  window.console = new Console ()
  document.body.append (console.elem)
  window.addEventListener ('error', evt => console.errorHandler (evt), true)
</script>

<script src="../dist/html.js"></script>
<script src="../dist/domex.min.js"></script>
<script src="scripts/samples.js"></script>

<script>(()=>{

  const log = console.log.bind (console)
  const { html, domex: { domex, DomEx, Domex } } = modules
  const { defineProperty:define } = Object
  const T = html.tokenTypes

  // For debugging
  define (Object.prototype, Symbol.toStringTag, {
    get: function () { return this.constructor.name }
  })

  // DOM tools
  const htmlns = 'http://www.w3.org/1999/xhtml'
  const byId = document.getElementById.bind (document)
  const $ = name => document.createElement (name)
  const setProps = (el, props) => {
    for (let k in props) el.setAttribute (k, props[k])
  }

  // native HTML parser
  function nativeParse (input) {
    return new DOMParser () .parseFromString (input, 'text/html')
  }


  // Main
  // ----

  const objectKey = Symbol ()
  const samples = window ['html-samples']

  const ui = domex `

    li@tab.-button [data-key=$]
      > "Sample " + $;

    ul@tabs
      > @tab*;

    main@main
      > h1 "HTML Parser"
      + p "This is a test page for the HTML parser,"
      + @tabs#tabs ~samples
      + textarea#input + button#submit "Run"
      + div#view1 "Browser"
      + div#view2 "Html Parser";
    
    @main
  `

  function main () {

    document.body.append (ui.render ({ samples }) .elem)

    // makeTabs (samples)
    showSample (samples[0])

    const submit = byId ('submit')
    
    submit .addEventListener ('click', evt => {
      showSample (input.value)
    })

    document.addEventListener ('click', evt => {
      if (objectKey in evt.target) {
        log (evt.target [objectKey])
        window.$ = evt.target [objectKey]
      }
      if ('key' in evt.target.dataset)
        showSample (samples [+evt.target.dataset.key])

    })
    
    window.addEventListener ('keydown', evt => {
      if (evt.key === 'Enter' && evt.ctrlKey || evt.metaKey)
        showSample (input.value)
    })
    
    input.focus ()
  }

  setTimeout (main)

  // OK lets create the tree
  // MDN: In addition, every kind of DOM node is represented by an interface based on Node. These include Attr, CharacterData (which Text, Comment, and CDATASection are all based on), ProcessingInstruction, DocumentType, Notation, Entity, and EntityReference.

  function showSample (sample) {
    window.console.clear ()
    const [input, view1, view2] = ['input', 'view1', 'view2'] .map (byId)
    input.value = sample
    view1.innerHTML = view2.innerHTML = ''
    view1.append ('native', showTree (nativeParse (sample)))
    view2.append ('parser', showTree (html.parse (sample)))
  }

  function showTree (domNode) {
    let elem, label, clss

    if (domNode instanceof Text) {
      clss = (/^\s*$/.test (domNode.data)) ? 'space' : 'text'
      elem = $('span')
      elem.append (domNode.data)
      elem.className = clss
      elem[objectKey] = domNode
      return elem
    }
    if (typeof domNode === 'string') {
      clss = (/^\s*$/.test (domNode)) ? 'space' : 'text'
      elem = $('span')
      elem.append (domNode)
      elem.className = clss
      elem[objectKey] = domNode
      return elem
    }

    elem = $('div')
    if (domNode instanceof Document || domNode instanceof html.Document)
      label = '#document'

    else if (domNode instanceof Comment || domNode[0] === T.Comment)
      label = '<!-->'

    else if (domNode instanceof Element || domNode instanceof html.Node || domNode instanceof html.Leaf) {
      label = (domNode.tagName||domNode.name).toLowerCase ()
      if (domNode.namespaceURI && domNode.namespaceURI !== htmlns)
        label = domNode.namespaceURI.split('/').pop () + ':' + label
    }

    // log (domNode.__proto__)
    elem.append (label)
    elem[objectKey] = domNode.frame ? _frameInfo (domNode.frame) : domNode
    
    if (clss) elem.classList.add(clss)
    let ul; elem.append ((ul = $('div')))
    ul.className = 'children'

    const children = domNode instanceof HTMLTemplateElement ?
      domNode.content.childNodes : domNode.childNodes || domNode.children || []
    for (let x of children) {
      ul.append (showTree (x))
    }
    return elem
  }
  
  function _frameInfo ({ node, flags, closable, allowed, openable, openFor = 0n, paths }) {
    return {
      name: node.name,
      flags: html.printInfo (flags),
      closable: html.printInfo (closable),
      openable: html.printInfo (openable),
      allowed: html.printInfo (allowed),
      openFor: html.printInfo (openFor),
      paths
    }
  }

})()</script>
