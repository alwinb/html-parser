(()=>{var j=(t,n)=>()=>(n||(n={exports:{}},t(n.exports,n)),n.exports);var ee=j((et,re)=>{var Ye=console.log.bind(console),V=1,W=511,_e=~W,Se=(...t)=>(n,...l)=>[String.raw(...t).replace(/\s+/g,""),V++<<9|n,...l],xe=()=>["",V++<<9],Ee=()=>V++<<9,Ie=(t={},n=0)=>new Proxy({},{get:(l,e)=>t[e]||(t[e]=1<<n++)}),oe={},{START:R,END:L,SKIP:H,LEAF:O,ASSOC:M,INFIX:J,PREFIX:P,POSTFIX:Q,GROUP:q}=Ie(oe),ze=t=>(...n)=>[String.raw(...n).replace(/\s+/g,""),t],[Ze,Te,$e,je,Re,Oe,Pe]=[R,O,P,J,M,Q,L].map(ze);function le(t){let n="",l=[],e=new RegExp(t.map(([i,o,...d])=>(l.push({type:o,info:d}),`(${i})`)).join("|"),"ys");e.infos=l,Object.defineProperty(e,"next",{value:s});function s(i,o){this.lastIndex=o;let d=this.exec(i);if(!d)return null;let c=1;for(;d[c]==null;)c++;let{type:u,info:A}=l[c-1];return[u,d[c],...A]}return e}function De(t){let n={},l={};for(let e in t){let s=t[e],{types:i,lexer:o}=qe(e,s,t);n[e]=o,l[e]=i}return{lexers:n,types:l}}function qe(t,n,l){let{end:e,skip:s={},sig:i=[]}=n,o=[],d=[],c={};for(let _ in s){let r=s[_];o.push([r,H]),d.push([r,H])}d.push([e[0],L]);for(let _=0,r=i.length;_<r;_++)for(let m in i[_]){let p=i[_][m],f=Ee(),h=0;if(typeof p[0]=="number"){let[g,w,S,E]=p;c[m]=f|g|q,h=[w,f|R|g,_,S]}else{let[g,w]=p;c[m]=f|=w,h=[g,f],f&O||(h[2]=_)}h[1]&(P|O)?o.push(h):d.push(h)}let u=t,A=le(o),y=le(d);return{name:u,types:c,lexer:{name:u,Before:A,After:y}}}var Z=Symbol("PRE "),ae=Symbol("POST");function Ne(t,n,l,e=(...s)=>s){let s,i,o,d,c,u,A,y;return this.parse=m,this;function _(p){let f=new Y(n,t[n[3]]);return s=[f],d=0,c=1,u=0,o=p,i=null,A=f.lexer,y=Z,f}function r(){let p=y===Z?A.Before:A.After,f=p.next(o,d);if(f==null){if(d<o.length&&p.lastIndex<d||y===Z)throw new Ce(o,d,c,u);return l}else f[1]===`
`&&(c++,u=d+1);return d=p.lastIndex,f}function m(p){for(let f,{ops:h,builds:g}=_(p);;){let w=f||r(),S=f?f[0][0]:w[0],E=S&(O|R|H)?-1:h.length-1;for(;E>=0;E--){let v=h[E],z=typeof v[0]=="number"?v:v[0];if(!(S&L||Fe(z,w)))break;h.length--;let B=z[3],G=g.length-B;z.length=2,g[G]=z[0]&q?e(...v.concat(g.splice(G,B))):e(v,...g.splice(G,B))}if(S&L){if(f=s.pop().collapse(w),s.length)({ops:h,builds:g,lexer:A}=s[s.length-1]);else return e(...f);continue}if(S&R){let v=new Y(w,t[w[3]]);({ops:h,builds:g,lexer:A}=s[s.length]=v),y=Z}else if(S&O)g[g.length]=f?e(...f):e(w),y=ae;else if(h.length&&S&M&&w[0]===h[h.length-1][0])h[h.length-1][3]++,y=Z;else if(S&(P|J|M)){h[h.length]=w;let v=S&q?w[0]:w;v[3]=v[0]&P?1:2,y=Z}else if(S&Q){let v=g.length-1;S&q?(w[0].length=2,g[v]=e(...w,g[v])):(w.length=2,g[v]=e(w,g[v])),y=ae}f=null}}}var ce=/([^\n]{0,80})/ys;function Ce(t,n,l,e){let s=Math.max(e,n-80);ce.lastIndex=e;let i=ce.exec(t)[1];return new SyntaxError(`Invalid expression. At line ${l}:${n-e}:

		${i}
		${"^".padStart(n-e+1)}`)}function Fe(t,n){let l=t[2],e=n[2];return l>e?!0:!!(l===e&&l[0]&W===Q)}var Y=class{constructor(n,l){this.opener=n,this.lexer=l,this.ops=[],this.builds=[]}collapse(n){let[l,e,s]=this.opener,i=l&P?1:l&J|M?2:0,o=[l&~R|q,e+n[1]];return i&&o.push(s,i),[o,this.builds[0]]}};re.exports={compile:De,Parser:Ne,Roles:oe,token:Se,tokenType:xe,roleMask:W,typeMask:_e,start:Ze,atom:Te,prefix:$e,infix:je,assoc:Re,postfix:Oe,end:Pe}});var X=j((rt,ie)=>{var tt=console.log.bind(console),K=ee(),{token:nt,tokenType:T,start:st,atom:x,postfix:I,infix:U,assoc:te,end:ne}=K,{LEAF:se,POSTFIX:ue}=K.Roles,D=(...t)=>String.raw(...t).replace(/\s+/g,""),fe={space:D`[\t\f\x20]+`,newline:D`[\n]`,comment:D`// [^\n]*`},Le={Dom:{name:"Dom",skip:fe,end:ne`[)]`,sig:[{elem:x`    [a-zA-Z] [a-zA-Z0-9_\-]*`,deref:x`[@] [a-zA-Z] [a-zA-Z0-9_\-]*`,value:x`[%] [a-zA-Z0-9_\-]*`,key:x`[$]`,group:[se,"[(]","Dom","[)]"],text:[se,'["]',"Chars",'["]']},{declare:te`[;]`},{orelse:te`[|]`},{descend:U`[>]`,sibling:U`[+]`},{class:I`[.] [a-zA-Z_\-] [a-zA-Z0-9_\-]*`,hash:I`[#] [a-zA-Z_\-] [a-zA-Z0-9_\-]*`,def:I`[@] [a-zA-Z_] [a-zA-Z0-9_]*`,ttest:I` :: [a-zA-Z_] [a-zA-Z0-9_]*`,test:I`[:] [a-zA-Z_] [a-zA-Z0-9_]*`,bind:I`[~] [a-zA-Z_] [a-zA-Z0-9_]*`,iter:I`[*] (?:[a-zA-Z_] [a-zA-Z0-9_]*)?`,addvalue:I`[%] (?:[a-zA-Z_] [a-zA-Z0-9_]*)?`,addkey:I`[$]`,addtext:[ue,'["]',"Chars",'["]'],attr:[ue,"[[]","Attr","]"]}]},Attr:{name:"Attr",skip:fe,end:ne`\]`,sig:[{unquoted:x`[a-zA-Z] [a-zA-Z0-9_\-]*`,valueIn:x`[%] [a-zA-Z0-9]*`,keyIn:x`[$]`,stringIn:[se,D`["]`,"Chars",D`["]`]},{collate:te`.{0} (?![[=])`},{assign:U`[=]`}]},Chars:{name:"Chars",end:ne`["]`,sig:[{strChars:x`[^\x00-\x19\\"]+`,escape:x`[\\]["/\\bfnrt]`,hexescape:x`[\\]u[a-fA-F0-9]{4}`,empty:x`.{0}(?=")`},{strCat:U`.{0}(?!")`}]}},$=K.compile(Le),de={void:T(),letin:T(),withlib:T(),context:T(),append:T(),unsafeRaw:T()},C={};for(let t in de)C[t]=de[t][1];for(let t in $.types)for(let n in $.types[t])C[n]=$.types[t][n];var pe={};for(let t in C)pe[C[t]]=t;function Me(t,n){let l=$.lexers.Dom.Before.next("("),e=$.lexers.Dom.After.next(")");return new K.Parser($.lexers,l,e,n).parse(t)}ie.exports={nodeTypes:C,typeNames:pe,parse:Me}});var me=j((ct,be)=>{var ot=console.log.bind(console),{signatures:lt,nodeTypes:a,typeNames:Ke}=X(),{typeMask:at}=ee();function F({expr:t,ops:n,name:l}){if(n){let e,s;for(e=n;e[s=e.length-1]!=null;e=e[s]);e[s]=t,t=n}return l!=null&&(t=[[a.letin,l],t,[[a.deref,l]]]),t}var Ue={b:"\b",f:"\f",n:`
`,r:"\r",t:"	"};function Xe(...t){let[[n,l],e,s]=t;switch(n){case a.group:return e;case a.text:return{expr:[[a.text,e]],ops:null,name:null};case a.elem:case a.key:case a.deref:return{expr:t,ops:null,name:null};case a.value:{let c=[[a.value,"%"]],u=l.length>1?[[a.bind,"~"+l.substr(1)],null]:null;return{expr:c,ops:u,name:null}}case a.sibling:case a.orelse:{let c=[t[0]];for(let u=1,A=t.length;u<A;u++)c[u]=F(t[u]);return{expr:c}}case a.declare:let i=Object.create(null),o=t.length-1;for(let c=1;c<o;c++){let u=F(t[c]);if(u[0][0]===a.letin){let A=u[0][1];i[A]=u[1]}}let d=t[o];return{expr:[[a.withlib,i],d.expr],name:d.name,ops:d.ops};case a.descend:{let u=[[a.descend,l],e.expr,F(s)];return{expr:F({ops:e.ops,expr:u,name:e.name})}}case a.def:if(e.name!=null)throw new Error(`expression ${l} is already named ${name}`);return{name:l,expr:e.expr,ops:e.ops};case a.iter:return{ops:[t[0],e.ops],name:null,expr:e.expr};case a.bind:case a.test:case a.ttest:case a.class:case a.hash:return{ops:[t[0],e.ops],name:e.name,expr:e.expr};case a.attr:{switch(e[0][0]){case a.unquoted:case a.collate:case a.assign:break;default:throw new TypeError("Invalid attribute expression")}return{ops:[t[0],e,s.ops],name:s.name,expr:s.expr}}case a.addtext:{let c=[[a.append," "],s.expr,[[a.text,e]]];return{ops:s.ops,name:s.name,expr:c}}case a.addkey:{let c=[[a.append," "],e.expr,[[a.key,"$"]]];return{ops:e.ops,name:e.name,expr:c}}case a.addvalue:{let c=[[a.value,l]];l.length>1&&(c=[[a.bind,"~"+l.substr(1)],c]);let u=[[a.append," "],e.expr,c];return{ops:e.ops,name:e.name,expr:u}}case a.collate:for(let c=1,u=t.length;c<u;c++)switch(t[c][0][0]){case a.assign:case a.unquoted:break;default:throw new TypeError("Invalid attribute expression")}return t;case a.unquoted:case a.valueIn:case a.keyIn:return t;case a.stringIn:return[[t[0][0],e]];case a.assign:{let c=s[0][0];if(e[0][0]!==a.unquoted)throw new TypeError("Lhs of `=` must be an attribute name token");if(c===a.assign)throw new TypeError("Rhs of `=` must not be an assignment");return[t[0],e,s]}case a.strChars:return l;case a.escape:return Ue[l[1]]||l[1];case a.empty:return"";case a.hexescape:return String.fromCodePoint(parseInt(l.substr(2),16));case a.strCat:return e+s;default:throw new TypeError(`compile: unknown operator type: ${n} ${Ke[n]}`)}}be.exports={preEval:Xe,bindDefs:F}});var ke=j((dt,he)=>{var it=console.log.bind(console),{nodeTypes:b,typeNames:Be,parse:ut}=X(),ge=Symbol("Domex.ref"),k=[[b.void,"\u03B5"]],Ve=({createElement:t,createTextNode:n,_createRawHTMLNode:l})=>function e(s,i={}){let{data:o,key:d,lib:c={},marks:u={},depth:A=0}=i,y=s[0],_=y[0];switch(_){case b.void:return[null,k,k];case b.elem:return[t(y[1]),k,k];case b.text:return[n(y[1]),k,k];case b.unsafeRaw:return[l(o==null?"":String(o)),k,k];case b.key:return[n(d==null?"":String(d)),k,k];case b.value:return[n(o==null?"":String(o)),k,k];case b.deref:{let r=y[1],m=typeof o;if(!(r in c))throw new ReferenceError("Unknown reference "+y[1]);if(o!=null&&m==="object"||m==="function"){u[r]==null&&(u[r]=new WeakMap);let f=u[r].get(o);f==null||f>A?u[r].set(o,A):A>f&&(o=Symbol("Circular"))}i={data:o,key:d,lib:c,marks:u,depth:A+1};let p=e(c[r],i);return p[0]&&(p[0][ge]={data:o,key:d}),p}case b.withlib:{let r=Object.create(c);return Object.assign(r,y[1]),e(s[1],{data:o,key:d,lib:r,marks:u,depth:A})}case b.context:return e(s[1],y[1]);case b.letin:{let r=Object.create(c);return r[y[1]]=s[1],e(s[2],{data:o,key:d,lib:r,marks:u,depth:A})}case b.bind:return d=y[1].substr(1),o=o==null?void 0:o[d],e(s[1],{data:o,key:d,lib:c,marks:u,depth:A});case b.ttest:{let r=y[1].substr(2),m=o===null?"null":Array.isArray(o)?"array":typeof o;return m==="object"&&o.type&&(m=o.type),r!==m?[null,k,k]:e(s[1],i)}case b.test:{let r=y[1].substr(1);return(o==null?!1:o[r])?e(s[1],i):[null,k,k]}case b.iter:{if(o==null)return[null,k,k];if(typeof o!="object"&&(o=[]),o[ye]==null)return o=y[1].length>1?we(o[y[1].substr(1)]):we(o),o[ye]=!0,e(s,{data:o,key:d,lib:c,marks:u,depth:A});{let r=o.next();if(r.done)return[null,k,k];let[m,p]=r.value,[f,h,g]=e(s[1],{data:p,key:m,lib:c,marks:u,depth:A}),w=N(g,[[b.context,i],s]);return[f,h,N(g,w)]}}case b.descend:{let[r,m,p]=e(s[1],i);if(!r)return[null,k,k];let f=[[b.context,{data:o,key:d,lib:c,marks:u,depth:A}],s[2]];return[r,N(m,f),p]}case b.sibling:{let[r,m,p]=e(s[1],i);if(r==null)return e(s[2],i);let f=[[b.context,i],N(p,s[2])];return[r,m,f]}case b.append:{let[r,m,p]=e(s[1],i);if(r==null)return[null,k,k];let f=N(m,[[b.context,i],s[2]]);return[r,f,p]}case b.orelse:{for(let r=1,m=s.length;r<m;r++){let[p,f,h]=e(s[r],i);if(p!=null)return[p,f,h]}return[null,k,k]}case b.class:{let[r,m,p]=e(s[1],i);return r&&r.classList&&r.classList.add(y[1].substr(1)),[r,m,p]}case b.hash:{let[r,m,p]=e(s[1],i);return r&&r.setAttribute&&r.setAttribute("id",y[1].substr(1)),[r,m,p]}case b.attr:{let[r,m,p]=e(s[2],i);return r&&r.setAttribute&&Ge(r,s[1],i),[r,m,p]}default:throw new TypeError(`eval: unknown operator type: ${_} ${Be[_]}`)}};function N(t,n){return t[0][0]===b.void?n:n[0][0]===b.void?t:[[b.sibling,"+"],t,n]}function Ge(t,n,l){if(n[0][0]===b.collate)for(let e=0,s=n.length;e<s;e++)Ae(t,n[e],l);else Ae(t,n,l)}function Ae(t,n,l){n[0][0]===b.unquoted&&t.setAttribute(n[0][1],""),n[0][0]===b.assign&&t.setAttribute(n[1][0][1],We(n[2],l))}function We([[t,n]],l){let e=l.data;switch(t){case b.keyIn:return l.key;case b.valueIn:return e==null?"":String(n==="%"?e:e[n.substr(1)]);default:return n}}function*He(){}var ft=He.constructor,ye=Symbol("unfold.generator");function*we(t){if(t!=null)if(Symbol.iterator in t){let n=0;for(let l of t)yield[n++,l]}else yield*Object.entries(t)}he.exports={createUnfold:Ve,refKey:ge}});var ve=j(()=>{(()=>{let{signatures:t,parse:n,nodeTypes:l}=X(),{fold:e,preEval:s,bindDefs:i}=me(),{createUnfold:o,refKey:d}=ke(),c=document.createElement.bind(document),u=document.createTextNode.bind(document),A=o({createElement:c,createTextNode:u}),y={"@default":i(n(`
  ( span::number    .number    > %
  | span::string    .string    > %
  | span::boolean   .boolean   > %
  | span::null      .null      > "null"
  | span::function  .function  > "function " + %name
  | span::undefined .undefined > "undefined"
  | span::symbol    .symbol    > %
  | ul  ::array     .array     > li* > @default
  | dl  ::object    .object    > di* > dt $ + (dd > @default)
  | dl   .unknown              > di* > dt $ + (dd > @default) )`,s)),"@unsafe-raw-html":[[l.unsafeRaw,"@unsafe-raw-html"]]};class _{constructor(g){this.ast=i(n(g,s))}render(g){let w={data:g,lib:y},S=document.createDocumentFragment(),{elem:E,deriv:v}=r(this.ast,w);for(;E;)S.append(E),{elem:E,deriv:v}=r(v,w);return{elem:S.childNodes[0],elems:S}}}function r(h,g){let[w,S,E]=A(h,g);if(w&&w instanceof Element&&S){let{elem:v,deriv:z}=r(S,g);for(;v;)w.append(v),{elem:v,deriv:z}=r(z,g)}return{elem:w,deriv:E}}_.refKey=d;let p={version:"0.7.0",DomEx:_,domex:(...h)=>new _(String.raw(...h)),Domex:_},f=window.modules=window.modules||{};f.domex=p})()});ve();})();
