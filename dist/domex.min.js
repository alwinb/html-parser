(()=>{var R=(t,o)=>()=>(o||(o={exports:{}},t(o.exports,o)),o.exports);var Q=R((He,se)=>{var We=console.log.bind(console),G=1,V=511,ve=~V,_e=(...t)=>(o,...c)=>[String.raw(...t).replace(/\s+/g,""),G++<<9|o,...c],Se=()=>["",G++<<9],Ee=()=>G++<<9,Ie=(t={},o=0)=>new Proxy({},{get:(c,e)=>t[e]||(t[e]=1<<o++)}),re={},{START:O,END:M,SKIP:W,LEAF:q,ASSOC:K,INFIX:H,PREFIX:P,POSTFIX:J,GROUP:D}=Ie(re),ze=t=>(...o)=>[String.raw(...o).replace(/\s+/g,""),t],[Ze,xe,Te,$e,je,Re,Oe]=[O,q,P,H,K,J,M].map(ze);function oe(t){let o="",c=[],e=new RegExp(t.map(([u,l,...f])=>(c.push({type:l,info:f}),`(${u})`)).join("|"),"ys");e.infos=c,Object.defineProperty(e,"next",{value:r});function r(u,l){this.lastIndex=l;let f=this.exec(u);if(!f)return null;let s=1;for(;f[s]==null;)s++;let{type:i,info:y}=c[s-1];return[i,f[s],...y]}return e}function Pe(t){let o={},c={};for(let e in t){let r=t[e],{types:u,lexer:l}=qe(e,r,t);o[e]=l,c[e]=u}return{lexers:o,types:c}}function qe(t,o,c){let{end:e,skip:r={},sig:u=[]}=o,l=[],f=[],s={};for(let b in r){let n=r[b];l.push([n,W]),f.push([n,W])}f.push([e[0],M]);for(let b=0,n=u.length;b<n;b++)for(let d in u[b]){let h=u[b][d],k=Ee(),v=0;if(typeof h[0]=="number"){let[g,_,m,S]=h;s[d]=k|g|D,v=[_,k|O|g,b,m]}else{let[g,_]=h;s[d]=k|=_,v=[g,k],k&q||(v[2]=b)}v[1]&(P|q)?l.push(v):f.push(v)}let i=t,y=oe(l),A=oe(f);return{name:i,types:s,lexer:{name:i,Before:y,After:A}}}var T=Symbol("PRE "),le=Symbol("POST"),ae=/([^\n]{0,80})/ys;function De(t,o,c,e=(...r)=>r){let r=0,u=1,l=0,f=T,s=o,i=null,y=[],A,b,n,d=t[o[2]];return this.parse=k,this;function h(v,g){let _=v[2],m=g[2];return _>m?!0:!!(_===m&&_[0]&V===J)}function k(v){do{if(i==null&&s==null){let m=f===T?d.Before:d.After;if(s=m.next(v,r),s)s[1]===`
`&&(u++,l=r+1);else{let S=r<v.length&&m.lastIndex<r;if(S||!S&&f===T){let E=Math.max(l,r-80);ae.lastIndex=l;let x=ae.exec(v)[1];throw new SyntaxError(`Invalid expression. At line ${u}:${r-l}:

		${x}
		${"^".padStart(r-l+1)}`)}s=c}r=m.lastIndex}let g=i?i[0][0]:s[0],_=g&(q|O|W)?-1:b.length-1;for(;_>=0;_--){let m=b[_],S=typeof m[0]=="number"?m:m[0];if(!(g&M||h(S,s)))break;b.length--;let E=S[3],x=n.length-E;S.length=2,n[x]=S[0]&D?e(...m.concat(n.splice(x,E))):e(m,...n.splice(x,E))}if(g&M){y.pop();let[m,S,z]=A,E=m&~O|D,x=[E,S+s[1]],ne=E&P?1:E&H|K?2:0;if(s=[x,n[0]],i=s,!y.length)return e(...i);ne&&x.push(z,ne),{opener:A,ops:b,builds:n,lexer:d}=y[y.length-1];continue}if(g&O){A=s;let m=A[3];b=[],n=[],d=t[m],y.push({opener:A,ops:b,builds:n,lexer:d}),f=T}else if(g&q)n[n.length]=i?e(...i):e(s),f=le;else if(b.length&&g&K&&s[0]===b[b.length-1][0])b[b.length-1][3]++,f=T;else if(g&(P|H|K)){b[b.length]=s;let m=g&D?s[0]:s;m[3]=m[0]&P?1:2,f=T}else if(g&J){let m=n.length-1;g&D?(s[0].length=2,n[m]=e(...s,n[m])):(s.length=2,n[m]=e(s,n[m])),f=le}i=s=null}while(1)}}se.exports={compile:Pe,Parser:De,Roles:re,token:_e,tokenType:Se,roleMask:V,typeMask:ve,start:Ze,atom:xe,prefix:Te,infix:$e,assoc:je,postfix:Re,end:Oe}});var B=R((et,ce)=>{var Je=console.log.bind(console),U=Q(),{token:Qe,tokenType:$,start:Ye,atom:I,postfix:Z,infix:X,assoc:Y,end:ee}=U,{LEAF:te,POSTFIX:ie}=U.Roles,C=(...t)=>String.raw(...t).replace(/\s+/g,""),ue={space:C`[\t\f\x20]+`,newline:C`[\n]`,comment:C`// [^\n]*`},Ce={Dom:{name:"Dom",skip:ue,end:ee`[)]`,sig:[{elem:I`    [a-zA-Z] [a-zA-Z0-9_\-]*`,deref:I`[@] [a-zA-Z] [a-zA-Z0-9_\-]*`,value:I`[%] [a-zA-Z0-9_\-]*`,key:I`[$]`,group:[te,"[(]","Dom","[)]"],text:[te,'["]',"Chars",'["]']},{declare:Y`[;]`},{orelse:Y`[|]`},{descend:X`[>]`,sibling:X`[+]`},{class:Z`[.] [a-zA-Z_\-] [a-zA-Z0-9_\-]*`,hash:Z`[#] [a-zA-Z_\-] [a-zA-Z0-9_\-]*`,def:Z`[@] [a-zA-Z_] [a-zA-Z0-9_]*`,ttest:Z` :: [a-zA-Z_] [a-zA-Z0-9_]*`,test:Z`[:] [a-zA-Z_] [a-zA-Z0-9_]*`,bind:Z`[~] [a-zA-Z_] [a-zA-Z0-9_]*`,iter:Z`[*] (?:[a-zA-Z_] [a-zA-Z0-9_]*)?`,addvalue:Z`[%] (?:[a-zA-Z_] [a-zA-Z0-9_]*)?`,addkey:Z`[$]`,addtext:[ie,'["]',"Chars",'["]'],attr:[ie,"[[]","Attr","]"]}]},Attr:{name:"Attr",skip:ue,end:ee`\]`,sig:[{unquoted:I`[a-zA-Z] [a-zA-Z0-9_\-]*`,valueIn:I`[%] [a-zA-Z0-9]*`,keyIn:I`[$]`,stringIn:[te,C`["]`,"Chars",C`["]`]},{collate:Y`.{0} (?![[=])`},{assign:X`[=]`}]},Chars:{name:"Chars",end:ee`["]`,sig:[{strChars:I`[^\x00-\x19\\"]+`,escape:I`[\\]["/\\bfnrt]`,hexescape:I`[\\]u[a-fA-F0-9]{4}`,empty:I`.{0}(?=")`},{strCat:X`.{0}(?!")`}]}},j=U.compile(Ce),fe={void:$(),letin:$(),withlib:$(),context:$(),append:$(),unsafeRaw:$()},F={};for(let t in fe)F[t]=fe[t][1];for(let t in j.types)for(let o in j.types[t])F[o]=j.types[t][o];var de={};for(let t in F)de[F[t]]=t;function Fe(t,o){let c=j.lexers.Dom.Before.next("("),e=j.lexers.Dom.After.next(")");return new U.Parser(j.lexers,c,e,o).parse(t)}ce.exports={nodeTypes:F,typeNames:de,parse:Fe}});var me=R((rt,pe)=>{var tt=console.log.bind(console),{signatures:nt,nodeTypes:a,typeNames:Ne}=B(),{typeMask:st}=Q();function N({expr:t,ops:o,name:c}){if(o){let e,r;for(e=o;e[r=e.length-1]!=null;e=e[r]);e[r]=t,t=o}return c!=null&&(t=[[a.letin,c],t,[[a.deref,c]]]),t}var Le={b:"\b",f:"\f",n:`
`,r:"\r",t:"	"};function Me(...t){let[[o,c],e,r]=t;switch(o){case a.group:return e;case a.text:return{expr:[[a.text,e]],ops:null,name:null};case a.elem:case a.key:case a.deref:return{expr:t,ops:null,name:null};case a.value:{let s=[[a.value,"%"]],i=c.length>1?[[a.bind,"~"+c.substr(1)],null]:null;return{expr:s,ops:i,name:null}}case a.sibling:case a.orelse:{let s=[t[0]];for(let i=1,y=t.length;i<y;i++)s[i]=N(t[i]);return{expr:s}}case a.declare:let u=Object.create(null),l=t.length-1;for(let s=1;s<l;s++){let i=N(t[s]);if(i[0][0]===a.letin){let y=i[0][1];u[y]=i[1]}}let f=t[l];return{expr:[[a.withlib,u],f.expr],name:f.name,ops:f.ops};case a.descend:{let i=[[a.descend,c],e.expr,N(r)];return{expr:N({ops:e.ops,expr:i,name:e.name})}}case a.def:if(e.name!=null)throw new Error(`expression ${c} is already named ${name}`);return{name:c,expr:e.expr,ops:e.ops};case a.iter:return{ops:[t[0],e.ops],name:null,expr:e.expr};case a.bind:case a.test:case a.ttest:case a.class:case a.hash:return{ops:[t[0],e.ops],name:e.name,expr:e.expr};case a.attr:{switch(e[0][0]){case a.unquoted:case a.collate:case a.assign:break;default:throw new TypeError("Invalid attribute expression")}return{ops:[t[0],e,r.ops],name:r.name,expr:r.expr}}case a.addtext:{let s=[[a.append," "],r.expr,[[a.text,e]]];return{ops:r.ops,name:r.name,expr:s}}case a.addkey:{let s=[[a.append," "],e.expr,[[a.key,"$"]]];return{ops:e.ops,name:e.name,expr:s}}case a.addvalue:{let s=[[a.value,c]];c.length>1&&(s=[[a.bind,"~"+c.substr(1)],s]);let i=[[a.append," "],e.expr,s];return{ops:e.ops,name:e.name,expr:i}}case a.collate:for(let s=1,i=t.length;s<i;s++)switch(t[s][0][0]){case a.assign:case a.unquoted:break;default:throw new TypeError("Invalid attribute expression")}return t;case a.unquoted:case a.valueIn:case a.keyIn:return t;case a.stringIn:return[[t[0][0],e]];case a.assign:{let s=r[0][0];if(e[0][0]!==a.unquoted)throw new TypeError("Lhs of `=` must be an attribute name token");if(s===a.assign)throw new TypeError("Rhs of `=` must not be an assignment");return[t[0],e,r]}case a.strChars:return c;case a.escape:return Le[c[1]]||c[1];case a.empty:return"";case a.hexescape:return String.fromCodePoint(parseInt(c.substr(2),16));case a.strCat:return e+r;default:throw new TypeError(`compile: unknown operator type: ${o} ${Ne[o]}`)}}pe.exports={preEval:Me,bindDefs:N}});var Ae=R((ct,be)=>{var ot=console.log.bind(console),{nodeTypes:p,typeNames:Ke,parse:lt}=B(),he=Symbol("Domex.ref"),w=[[p.void,"\u03B5"]],Xe=({createElement:t,createTextNode:o,_createRawHTMLNode:c})=>function e(r,u={}){let{data:l,key:f,lib:s={},marks:i={},depth:y=0}=u,A=r[0],b=A[0];switch(b){case p.void:return[null,w,w];case p.elem:return[t(A[1]),w,w];case p.text:return[o(A[1]),w,w];case p.unsafeRaw:return[c(l==null?"":String(l)),w,w];case p.key:return[o(f==null?"":String(f)),w,w];case p.value:return[o(l==null?"":String(l)),w,w];case p.deref:{let n=A[1],d=typeof l;if(!(n in s))throw new ReferenceError("Unknown reference "+A[1]);if(l!=null&&d==="object"||d==="function"){i[n]==null&&(i[n]=new WeakMap);let k=i[n].get(l);k==null||k>y?i[n].set(l,y):y>k&&(l=Symbol("Circular"))}u={data:l,key:f,lib:s,marks:i,depth:y+1};let h=e(s[n],u);return h[0]&&(h[0][he]={data:l,key:f}),h}case p.withlib:{let n=Object.create(s);return Object.assign(n,A[1]),e(r[1],{data:l,key:f,lib:n,marks:i,depth:y})}case p.context:return e(r[1],A[1]);case p.letin:{let n=Object.create(s);return n[A[1]]=r[1],e(r[2],{data:l,key:f,lib:n,marks:i,depth:y})}case p.bind:return f=A[1].substr(1),l=l==null?void 0:l[f],e(r[1],{data:l,key:f,lib:s,marks:i,depth:y});case p.ttest:{let n=A[1].substr(2),d=l===null?"null":Array.isArray(l)?"array":typeof l;return d==="object"&&l.type&&(d=l.type),n!==d?[null,w,w]:e(r[1],u)}case p.test:{let n=A[1].substr(1);return(l==null?!1:l[n])?e(r[1],u):[null,w,w]}case p.iter:{if(l==null)return[null,w,w];if(typeof l!="object"&&(l=[]),l[ge]==null)return l=A[1].length>1?ye(l[A[1].substr(1)]):ye(l),l[ge]=!0,e(r,{data:l,key:f,lib:s,marks:i,depth:y});{let n=l.next();if(n.done)return[null,w,w];let[d,h]=n.value,[k,v,g]=e(r[1],{data:h,key:d,lib:s,marks:i,depth:y}),_=L(g,[[p.context,u],r]);return[k,v,L(g,_)]}}case p.descend:{let[n,d,h]=e(r[1],u);if(!n)return[null,w,w];let k=[[p.context,{data:l,key:f,lib:s,marks:i,depth:y}],r[2]];return[n,L(d,k),h]}case p.sibling:{let[n,d,h]=e(r[1],u);if(n==null)return e(r[2],u);let k=[[p.context,u],L(h,r[2])];return[n,d,k]}case p.append:{let[n,d,h]=e(r[1],u);if(n==null)return[null,w,w];let k=L(d,[[p.context,u],r[2]]);return[n,k,h]}case p.orelse:{for(let n=1,d=r.length;n<d;n++){let[h,k,v]=e(r[n],u);if(h!=null)return[h,k,v]}return[null,w,w]}case p.class:{let[n,d,h]=e(r[1],u);return n&&n.classList&&n.classList.add(A[1].substr(1)),[n,d,h]}case p.hash:{let[n,d,h]=e(r[1],u);return n&&n.setAttribute&&n.setAttribute("id",A[1].substr(1)),[n,d,h]}case p.attr:{let[n,d,h]=e(r[2],u);return n&&n.setAttribute&&Ue(n,r[1],u),[n,d,h]}default:throw new TypeError(`eval: unknown operator type: ${b} ${Ke[b]}`)}};function L(t,o){return t[0][0]===p.void?o:o[0][0]===p.void?t:[[p.sibling,"+"],t,o]}function Ue(t,o,c){if(o[0][0]===p.collate)for(let e=0,r=o.length;e<r;e++)we(t,o[e],c);else we(t,o,c)}function we(t,o,c){o[0][0]===p.unquoted&&t.setAttribute(o[0][1],""),o[0][0]===p.assign&&t.setAttribute(o[1][0][1],Be(o[2],c))}function Be([[t,o]],c){let e=c.data;switch(t){case p.keyIn:return c.key;case p.valueIn:return e==null?"":String(o==="%"?e:e[o.substr(1)]);default:return o}}function*Ge(){}var at=Ge.constructor,ge=Symbol("unfold.generator");function*ye(t){if(t!=null)if(Symbol.iterator in t){let o=0;for(let c of t)yield[o++,c]}else yield*Object.entries(t)}be.exports={createUnfold:Xe,refKey:he}});var ke=R(()=>{(()=>{let{signatures:t,parse:o,nodeTypes:c}=B(),{fold:e,preEval:r,bindDefs:u}=me(),{createUnfold:l,refKey:f}=Ae(),s=document.createElement.bind(document),i=document.createTextNode.bind(document),y=l({createElement:s,createTextNode:i}),A={"@default":u(o(`
  ( span::number    .number    > %
  | span::string    .string    > %
  | span::boolean   .boolean   > %
  | span::null      .null      > "null"
  | span::function  .function  > "function " + %name
  | span::undefined .undefined > "undefined"
  | span::symbol    .symbol    > %
  | ul  ::array     .array     > li* > @default
  | dl  ::object    .object    > di* > dt $ + (dd > @default)
  | dl   .unknown              > di* > dt $ + (dd > @default) )`,r)),"@unsafe-raw-html":[[c.unsafeRaw,"@unsafe-raw-html"]]};class b{constructor(g){this.ast=u(o(g,r))}render(g){let _={data:g,lib:A},m=document.createDocumentFragment(),{elem:S,deriv:z}=n(this.ast,_);for(;S;)m.append(S),{elem:S,deriv:z}=n(z,_);return{elem:m.childNodes[0],elems:m}}}function n(v,g){let[_,m,S]=y(v,g);if(_&&_ instanceof Element&&m){let{elem:z,deriv:E}=n(m,g);for(;z;)_.append(z),{elem:z,deriv:E}=n(E,g)}return{elem:_,deriv:S}}b.refKey=f;let h={version:"0.7.0",DomEx:b,domex:(...v)=>new b(String.raw(...v)),Domex:b},k=window.modules=window.modules||{};k.domex=h})()});ke();})();
